---
date: 2016-01-12 16:14
status: public
title: 'Chapter3-Move Generation'
---

# 走法
将一个局面的所有可能的走法罗列出来，可以告诉其他部分下一步可以往哪里走。
基于二维数组的棋盘定义（坐标系，行列），并默认黑棋在上方的0到4行，红棋在下方的5到9行，即坐标系以右下为正向，原点在黑方的左边的车（红方视角）。
为减少函数调用开销，可将所有走法判断写在一个长长的switch中代替。
# 效率问题
走法产生通常伴随搜索进行，调用频繁。规则复杂则判断繁琐，程序存在性能瓶颈。
可将每种棋子在某一位置上的最大可走步建成一个数据库，在产生走法时直接取出数据作少量判断即可。
以中国象棋中的象为例。规则是田字格走法，且象眼要空白，不能过河。一般做法如下： 
    
1. 先检查该棋子周围与该棋子横纵坐标差的绝对值均为2的位置是否落在己方半边棋盘上，超出则去除；
    
2. 检查剩下位置上是否有己方棋子，有则去除；
    
3. 检查剩下的位置方向上与该棋子横纵坐标差的绝对值均为1的象眼上是否有棋子，有则去除；
    
4. 剩下的位置为合法走步。
    
如果将象的可走位及象眼位置存入数据库，枚举象在某一位置的合法走步就只需：
    
1. 从库中去除该位置上象的可走位置，检查可走位上有无己方棋子；
    
2. 从库中取出该位置上象的象眼位置，检查象眼上有无棋子。
    
该方法的速度优势建立在取数据库中数据时的快速定址基础之上。而且该小型数据库应事先预读在物理内存中，以避免低速的磁盘数据访问。
    
参考比特棋盘。以象为例，如果用一个96bit（3个32bit）的比特棋盘来表示象棋中某个棋子的信息，那么可将某位置上象的可走位置放入一张比特棋盘，并置于数据库中，届时取出，并且与含有所有己方棋子的比特棋盘（通常预先由若干张比特棋盘按位或生成）进行与操作即可得到一张含有不可走位置的比特棋盘。象眼仿此。
    
两张不可走位棋盘通过按位或合成，然后与该象的所有可走位置的棋盘按位异或就得到含有所有合法可走位的比特棋盘。
    
整个过程由4次位操作构成，可以找出一个棋子的所有合法走步。
# 剪枝算法：一次生成所有走法？
    生成走法的同时伴随着搜索进行。对于一个局面的所有直接后继，有两种处理方案：
_一次产生一种走法然后搜索之_
_一次产生所有走法然后搜索之_

剪枝算法使得对一个局面的某一走法搜索之后可能不再需要搜索其他后继，故一次生成一种走法似乎更有效率。
    
但是剪枝效率依赖于节点的排列顺序。一次生成所有节点，然后以某种方式调整排列顺序可大大提高搜索效率。
# 内存的使用
中国象棋中，一般情况下每一局面有20~60种走法。
    
在基于深度优先的极大极小搜索当中，搜索的每一层都要具备一块内存以供存放走法队列。也就是说，如果每种走法需要8B来保存，那么搜索5层就需要预先申请约8Bx70x5=2800B的空间。特殊的搜索算法可能要保存更多走法。