# 题目
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

# 思路

  1.先求出根节点（前序序列第一个元素）。 
  2.将根节点带入到中序遍历序列中求出左右子树的中序遍历序列。 
  3.通过左右子树的中序序列元素集合带入前序遍历序列可以求出左右子树的前序序列。 
  4.左右子树的前序序列第一个元素分别是根节点的左右儿子 
  5.求出了左右子树的4种序列可以递归上述步骤

![](./~img/前序中序重建二叉树.png)
```c++
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    struct TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> in) {
        //判定递归终止条件；
        if(pre.size() == 0 || in.size() == 0) {
            return NULL;
        }
        //定义Node节点并其求根节点；
        int root = pre[0];
        TreeNode* node = new TreeNode(root);
        vector<int>::iterator it;
        //1.求左右子树的遍历序列；
        vector<int> preLeft, preRight, inLeft, inRight;
            //（1）.求根节点在中序遍历序列中的位置；
        vector<int>::iterator i;
        for(it = in.begin(); it != in.end(); it++) {
            if(root == *it) {
                i = it;
            }
        }
            //（2）.求左右子树的中序遍历子序列；
        int k = 0;
        for(it = in.begin(); it != in.end(); it++) {
            if(k == 0) {
                inLeft.push_back(*it);
            }
            else if(k == 1) {
                inRight.push_back(*it);
            }
            else {}
            if(it == i) {
                k = 1;
            } //?????it==i时的这个it，也被push_back了！！！
        }
            //（3）.求左右子树的前序遍历子序列；
        k = 0;
        vector<int>::iterator ite;
        for(it = pre.begin()+1; it != pre.end(); it++) {
            for(ite = inLeft.begin(); ite != inLeft.end(); ite++) {
                if(*it == *ite) {
                    preLeft.push_back(*it);
                    k = 1;
                }
            }
            if(k == 0) {
                preRight.push_back(*it);
            }
            k = 0;
        }
        //根据遍历序列求出跟的左右节点；
        node->left = reConstructBinaryTree(preLeft,inLeft);
        node->right = reConstructBinaryTree(preRight,inRight);
        //返回节点地址；
        return node;
    }
};
```

# 解决
链接：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6
来源：牛客网

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);
        return root;
    }
    //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}
    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) {
         
        if(startPre>endPre||startIn>endIn)
            return null;
        TreeNode root=new TreeNode(pre[startPre]);
         
        for(int i=startIn;i<=endIn;i++)
            if(in[i]==pre[startPre]){
                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);
                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);
            }
                 
        return root;
    }
}
```

# 我的解决方案

参考http://wiki.jikexueyuan.com/project/for-offer/question-six.html,与上面的类似。主要是控制递归的起点和终点。

```python
# -*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        pre = list(pre); tin = list(tin)
        if(pre==None or tin==None or len(pre)!=len(tin) or len(pre)<1):
            return
        preStart = 0;tinStart = 0
        preEnd = len(pre)-1; tinEnd = len(tin)-1
        
        # 取前序遍历的第一个数字，就是当前的根节点
        value = pre[preStart]
        index = tinStart
        
        # 在中序遍历的数组中找根节点的位置
        while index <= tinEnd and tin[index]!=value:
            index += 1
        # 如果在整个中序遍历的数组中没有找到，说明输入参数不合法
        if index>tinEnd:
            return
        # 创建当前根节点，并且为结点赋值
        node = TreeNode(value)
        
        # 递归构建当前根节点的左子树，左子树的元素个数： index-tinStart+1个
        # 左子树对应的前序遍历的位置在[preStart+1,preStart+index-tinStart]
        # 左子树对应的中序遍历的位置在[tinStart,index-1]
        # python list indice的原因，end位置用于切片时+1
        node.left = self.reConstructBinaryTree(pre[preStart+1:preStart+index-tinStart+1],\
                                              tin[tinStart:index-1+1])
        
        node.right = self.reConstructBinaryTree(pre[preStart+index-tinStart+1:tinEnd+1],\
                                                tin[index+1:tinEnd+1])
        return node
    
        
    def printTreeInOrder(self,rootNode):
        if rootNode != None:
            self.printTreeInOrder(rootNode.left)
            print str(rootNode.val) + " "
            self.printTreeInOrder(rootNode.right)
        return
    def printTreePreOrder(self,rootNode):
        if rootNode != None:
            print str(rootNode.val) + " "
            self.printTreePreOrder(rootNode.left)
            self.printTreePreOrder(rootNode.right)
        return
    def printTreePostOrder(self,rootNode):
        if rootNode != None:
            self.printTreePreOrder(rootNode.left)
            self.printTreePreOrder(rootNode.right)
            print str(rootNode.val) + " "
        return
def main():
    sol = Solution()
    preOrder = {1,2,3,4,5,6,7}
    inOrder = {3,2,4,1,6,5,7}
    #{1,2,4,7,3,5,6,8},{4,7,2,1,5,3,8,6}
    result = sol.reConstructBinaryTree(preOrder,inOrder)
    sol.printTreeInOrder(result)
    print 
    sol.printTreePreOrder(result)

    print 
    sol.printTreePostOrder(result)
if __name__ == '__main__':
    main()
```

# 根据前序中序求后序

```c++
#include <iostream>  
#include <fstream>  
#include <string>  
  
struct TreeNode  
{  
  struct TreeNode* left;  
  struct TreeNode* right;  
  char  elem;  
};  
  
  
TreeNode* BinaryTreeFromOrderings(char* inorder, char* preorder, int length)  
{  
  if(length == 0)  
    {  
      return NULL;  
    }  
  TreeNode* node = new TreeNode;//Noice that [new] should be written out.  
  node->elem = *preorder;  
  int rootIndex = 0;  
  for(;rootIndex < length; rootIndex++)//a variation of the loop  
    {  
      if(inorder[rootIndex] == *preorder)  
      break;  
    }  
  node->left = BinaryTreeFromOrderings(inorder, preorder +1, rootIndex);  
  node->right = BinaryTreeFromOrderings(inorder + rootIndex + 1, preorder + rootIndex + 1, length - (rootIndex + 1));  
  std::cout<<node->elem<<std::endl;  
  return node;  
}  
  
int main(int argc, char** argv){  
    char* pr="GDAFEMHZ";      
 char* in="ADEFGHMZ"; BinaryTreeFromOrderings(in, pr, 8); printf("\n"); return 0;}  
 ```