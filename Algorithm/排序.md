1. https://cnbin.github.io/blog/2015/12/10/ji-chong-pai-xu-yi-ji-qi-shi-jian-fu-za-du/
2. http://www.imooc.com/article/8633

**如果一个算法能够用这样的t(n)（n的一次函数）来定义行为，那么其性能为O(n log n).**

一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。
作者： visor_03389873 
链接：http://www.imooc.com/article/8633
来源：慕课网

- 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。
- 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。
- 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。
- 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。
- 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。

作者： visor_03389873 
链接：http://www.imooc.com/article/8633
来源：慕课网

# 1.选择排序：不稳定，时间复杂度 O(n2)

选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。

# 2.插入排序：稳定，时间复杂度 O(n2)

插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),©三次插入。
![](http://opkk27k9n.bkt.clouddn.com/17-7-2/42864609.jpg)

# 3.冒泡排序：稳定，时间复杂度 O(n2)

冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。

# 4.堆排序：不稳定，时间复杂度 O(nlog n)

堆排序是一种树形选择排序，在排序过程中，将A[n]看成是完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。
![](http://opkk27k9n.bkt.clouddn.com/17-7-4/43244998.jpg)
在排序一个大小为n的数组A，堆排序将其切分成两个相异的子数组，A[0,m)和A[m,n)，分别表示一个大小为m的堆和一个有n-m个元素的有序子数组。随着i从n-1迭代到1，堆排序交换堆中的最大元素（位置是A[0])和A[i]，使子数组A[i,n)的大小不断增长；然后堆排序执行heapify重构A[0,i)使其成为一个有效堆（图4-14描述了伪代码）。结果非空子数组A[i,n)将会有序，因为堆中的最大的元素保证比这个有序子数组中的任何一个元素都要小。


# 5.归并排序：稳定，时间复杂度 O(nlog n)

设有两个有序（升序）序列存储在同一数组中相邻的位置上，不妨设为A[l..m]，A[m+1..h]，将它们归并为一个有序数列，并存储在A[l..h]。

6.快速排序：不稳定，时间复杂度 最理想 O(nlogn) 最差时间O(n2)

快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。

>**为了改善快速排序的递归性能，一个广泛使用的技术是在排序大子数组时调用快速排序，在排序小子数组时使用插入排序。**

# 7.希尔排序：不稳定，时间复杂度 平均时间 O(nlogn) 最差时间O(ns) 1<s<2

在直接插入排序算法中，每次插入一个数，使有序序列只增加1个节点，并且对插入下一个数没有提供任何帮助。如果比较相隔较远距离（称为 增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。

![](http://ww2.sinaimg.cn/mw690/78f9859ejw1eytsnu35ilj20g505wwfb.jpg)

# 8. 中值排序
![](http://opkk27k9n.bkt.clouddn.com/17-7-2/20356151.jpg)

# 9. 计数排序
![](http://opkk27k9n.bkt.clouddn.com/17-7-5/11622745.jpg)

# 10. 桶排序
![](http://opkk27k9n.bkt.clouddn.com/17-7-5/55084352.jpg)

# 快排
# 

![](http://opkk27k9n.bkt.clouddn.com/17-7-4/53865361.jpg)
# 思路

实现快排的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，小的放左边，大的放右边。实现如下：

```cpp
/* 
    除了可以用来实现快排，还可以用来实现：
    * 在长度为n的数组中查找第k大的数字
    * 数组中出现次数超过一半的数字
    * 最小的k个数
*/
int Partition(int data[], int length, int start, int end)
{
    if(data==NULL || length<=0 || start<0 || end>=length)
        throw new std::exception("");//.............................
    int index = RandomInRange(start,end);
    Swap(&data[index], &data[end]);

    int small = start - 1;
    for(index=start; index<end; index++)
    {
        if(data[index] < data[end])
        {
            ++small;
            if(small!=index)
                Swap(&data[index],&data[small]);
        }
    }
    ++small;
    Swap(&data[small],&data[end]);
    return small;
}

```


```cpp
void QuickSort(int data[],int length, int start, int end)
{
    if (start==end)return;

    int index = Partition(data,length,start,end);

    if(index>start)
        QuickSort(data,length,start,index-1);
    if(index<end)
        QuickSort(data,length,index+1,end);
}  
```

# 选择排序算法的标准
![](http://opkk27k9n.bkt.clouddn.com/17-7-5/86610417.jpg)