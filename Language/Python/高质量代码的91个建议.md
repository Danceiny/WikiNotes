1.  str.format
`print '(greet) from (language).'.format(greet = "hello world",language = "python")`


2. 使用PEP8
pip install -U PEP8
pep8 --first optparse.py [--show-source]

3. 常量类
```python
class _const:
    class ConstError(TypeError):
        pass
    class ConstCaseError(ConstError):
pass
    def __setattr__(self, name, value):
        if self.__dict__.has_key(name):
            raise self.ConstError, "Can't change const.{}".format(name)
        if not name.isupper():
            raise self.ConstCaseError, "const name {} is not all uppercase".format
        self.__dict__[name] = value
import sys
sys.modules[__name__] = _const()
```

如果上面的代码对应的模块名为 const，使用时候只需要 import const，便可以直接定义 常量了，如以下代码:
```python
import const
const.COMPANY = "IBM"
```

无论采用哪一种方式来实现常量，都提倡将常量集中到一个文件中，因为这样有利于维 护，一旦需要修改常量的值，可以集中统一而不是逐个文件去检查。采用第二种方式实 现的常量可以这么做:将存放常量的文件命名为 constant.py ，并在其中定义一系列的 常量。

4. Pyhton字节码
可用dis模块分析。
```python
import dis
def swap1():
    x, y = 2, 3
    x, y = y, x
def swap2():
    x, y = 2, 3
    temp = x
    x=y
    y = temp
dis.dis(swap1)
dis.dis(swap2)
```


5. 生成器
```python
def fib():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
from itertools import islice
# islice(iterator,stop)
print list(islice(fib(), 5))
```


6. type
```
class type(object)
 |  type(object_or_name, bases, dict)
 |  type(object) -> the object's type
 |  type(name, bases, dict) -> a new type
```

```python
def enum(*posarg, **keysarg):
	return type("Enum", (object,), dict(zip(posarg, range(len(posarg))), **keysarg))
Seasons = enum("Spring", "Summer", "Autumn", Winter=1)
```
**不建议使用type进行类型检查**!!!
isinstance()。

7. 枚举
```python
from flufl.enum import Enum
class Seasons(Enum): # 继承自 Enum 定义枚举
    Spring = "Spring"
    Summer = 2
    Autumn = 3
    Winter = 4
Seasons = Enum("Seasons", "Spring Sumter Autumn Winter")
```

flufl.enum 提供了 `__members__` 属性，可以对枚举名称进行迭代。
可以直接使用 value 属性获取枚举元素的值，比如:
`print Seasons.Summer.value`

flufl.enum 不支持枚举元素的比较。比如不支持 Seasons.Summer < Seasons.Autumn

Python3.4 中根据 PEP435 加入了枚举 Enum，其实现主要参考 flufl.enum ，但两者之间还 是存在一些差别，如 flufl.enum 允许枚举继承，而 Enum 仅在父类没有任何枚举成员的时 候才允许继承等。如果要在 Python3.4 之前的版本中使用枚举 Enum，可以安装 Enum 的向 后兼容包 enum34。

8. 警惕eval的安全漏洞
原型：`eval(expression[,globals[,locals]])`。

如果传入 globals 参数的字典中缺少 `__builtins__` 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。
预防：`eval(expression,{"__builtins__":None})`

在需要使用 eval 的地方可用安全性更好的 ast.literal_eval 替代。


9. 使用enumerate获取序列迭代的索引和值
不适用于字典。

10. 编码问题
![](http://opkk27k9n.bkt.clouddn.com/17-7-6/69280758.jpg)  
