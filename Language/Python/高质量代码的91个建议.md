1.  str.format
`print '(greet) from (language).'.format(greet = "hello world",language = "python")`

![](http://opkk27k9n.bkt.clouddn.com/17-7-6/83131985.jpg)

2. 使用PEP8
pip install -U PEP8
pep8 --first optparse.py [--show-source]

3. 常量类
```python
class _const:
    class ConstError(TypeError):
        pass
    class ConstCaseError(ConstError):
pass
    def __setattr__(self, name, value):
        if self.__dict__.has_key(name):
            raise self.ConstError, "Can't change const.{}".format(name)
        if not name.isupper():
            raise self.ConstCaseError, "const name {} is not all uppercase".format
        self.__dict__[name] = value
import sys
sys.modules[__name__] = _const()
```

如果上面的代码对应的模块名为 const，使用时候只需要 import const，便可以直接定义 常量了，如以下代码:
```python
import const
const.COMPANY = "IBM"
```

无论采用哪一种方式来实现常量，都提倡将常量集中到一个文件中，因为这样有利于维 护，一旦需要修改常量的值，可以集中统一而不是逐个文件去检查。采用第二种方式实 现的常量可以这么做:将存放常量的文件命名为 constant.py ，并在其中定义一系列的 常量。

4. Pyhton字节码
可用dis模块分析。
```python
import dis
def swap1():
    x, y = 2, 3
    x, y = y, x
def swap2():
    x, y = 2, 3
    temp = x
    x=y
    y = temp
dis.dis(swap1)
dis.dis(swap2)
```


5. 生成器
```python
def fib():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b
from itertools import islice
# islice(iterator,stop)
print list(islice(fib(), 5))
```


6. type
```
class type(object)
 |  type(object_or_name, bases, dict)
 |  type(object) -> the object's type
 |  type(name, bases, dict) -> a new type
```

```python
def enum(*posarg, **keysarg):
	return type("Enum", (object,), dict(zip(posarg, range(len(posarg))), **keysarg))
Seasons = enum("Spring", "Summer", "Autumn", Winter=1)
```
**不建议使用type进行类型检查**!!!
isinstance()。

7. 枚举
```python
from flufl.enum import Enum
class Seasons(Enum): # 继承自 Enum 定义枚举
    Spring = "Spring"
    Summer = 2
    Autumn = 3
    Winter = 4
Seasons = Enum("Seasons", "Spring Sumter Autumn Winter")
```

flufl.enum 提供了 `__members__` 属性，可以对枚举名称进行迭代。
可以直接使用 value 属性获取枚举元素的值，比如:
`print Seasons.Summer.value`

flufl.enum 不支持枚举元素的比较。比如不支持 Seasons.Summer < Seasons.Autumn

Python3.4 中根据 PEP435 加入了枚举 Enum，其实现主要参考 flufl.enum ，但两者之间还 是存在一些差别，如 flufl.enum 允许枚举继承，而 Enum 仅在父类没有任何枚举成员的时 候才允许继承等。如果要在 Python3.4 之前的版本中使用枚举 Enum，可以安装 Enum 的向 后兼容包 enum34。

8. 警惕eval的安全漏洞
原型：`eval(expression[,globals[,locals]])`。

如果传入 globals 参数的字典中缺少 `__builtins__` 的时候，当前的全局命名空间将作为 globals 参数输入并且在表达式计算之前被解析。
预防：`eval(expression,{"__builtins__":None})`

在需要使用 eval 的地方可用安全性更好的 ast.literal_eval 替代。


9. 使用enumerate获取序列迭代的索引和值
不适用于字典。

10. 编码问题
![](http://opkk27k9n.bkt.clouddn.com/17-7-6/69280758.jpg)  


11. 使用with自动关闭资源
with语句的执行过程：

- 计算表达式的值，返回一个上下文管理器对象
- 加载上下文管理器对象的 `__exit__()` 方法以备后用
- 调用上下文管理器对象的 `__enter__()` 方法
- 如果 with 语句中设置了目标对象，则将 `__enter__()` 方法的返回值赋值给目标对象 执行 with 中的代码块
- 如果步骤 5 中代码正常结束，调用上下文管理其对象的 `__exit__()` 方法，其返回值直 接忽略
- 如果步骤 5 中代码执行过程中发生异常，调用上下文管理器对象的 `__exit__()` 方法， 并将异常类型、值及 traceback 信息作为参数传递给 `__exit__()` 方法。如果`__exit__()` 返回值为 false，则异常会被重新抛出;如果其返回值为 true，异常被挂 起，程序继续执行。

12. 自定义上下文管理器
```python
class MyContextManager(object):
def __enter__(self): # 实现 __enter__ 方法
        print "entering..."
    def __exit__(self, exception_type, exception_value, traceback):
        print "leaving"
        if exception_type is None:
            print "no exceptions!"
            return False
        elif exception_type is ValueError:
            print "value error!!!"
            return True
        else:
            print "other error"
            return True
with MyContextManager():
    print "Testing..."
    raise(ValueError) # 注释这一句会得到不同的效果
```

13. 使用else简化循环
![](http://opkk27k9n.bkt.clouddn.com/17-7-6/74245476.jpg)

14. 不要在finally中return

15. 字符串的基本用法
编写运行 Python2 上的程序，当需要判断变量是否为字符串时，应该使用 isinstance(s, basestring) ，这里的参数是 basestring 而不是 str 。因为 basestring 才是 str 和unicode 的基类，包含了普通字符串和 unicode 类型。

16. sort()  sorted()
```python
sorted(iterable[, cmp[, key[, reverse]]])
s.sort([cmp[, key[, reverse]]])
```
sorted() 函数会返回一个排序后的列表，原有列表 保持不变;而 sort() 函数会直接修改原有列表，函数返回为 None。

key 是一个带参数的函数，用来为每个元素提取比较值，默认为 None(即直接比较 每个元素).传入key比传入cmp效率要高。

![](http://opkk27k9n.bkt.clouddn.com/17-7-7/45355241.jpg)
```
from operator import itemgetter
class itemgetter(builtins.object)
 |  itemgetter(item, ...) --> itemgetter object
 |
 |  Return a callable object that fetches the given item(s) from its operand.
 |  After f = itemgetter(2), the call f(r) returns r[2].
 |  After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])
```


17. 使用copy模块进行深拷贝
copy.deepcopy().

18. 
