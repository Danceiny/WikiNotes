---
date: 2016-04-19 23:56
status: public
title: 'Chapter2-Debuggers and Debugger Design-python黑客'
---

# white-box debugger and black-box debugger
white:
>Most development platforms, or IDEs, contain a built-in debugger that enables developers to trace through their source code with a high degree of control.

black:
>While these debuggers are useful during development, a reverse engineer, or bug hunter, rarely has the source code available and must employ black-box debuggers for tracing target applications.
>A black-box debugger assumes that the software under inspection is completely opaque(不透明) to the hacker, and the only information available is in a disassembled format.

two subclasses of black-box debuggers:
* user mode     a processor mode under whith your user applications run
* kernel mode   highest level of privilege


List of user-mode debuggers:
* WindDbg, from Microsoft
* OllyDbg, from Oleh Yuschuk
* GNU Debugger(gdb), Linux

Intelligent Debugging:
* PyDbg, by Pedram Amini
* Immunity Debugger, from Immunity,Inc



In this chapter, we will focus on user-mode applications on the x86 platform. We will begin by examining some very basic CPU architecture, coverage of the stack, and the anatomy of a user-mode debugger. The goal is for you to be able create your own debugger for any operating system, so it is critical that you understand the low-level theory first.


# General-Purpose CPU Registers
In the x86 instruction set, a CPU uses 8 general-purpose registers:**EAX,EDX,ECX,ESI,EDI,EBP,ESP,EBX**.
1. EAX
**also called the *accumulator register*, is used for performing calculations as well as storing return values from function calls.**

Most basic operations like add, subtract, and compare are optimized to use the EAX register. As well, more specialized operations like multiplication or division can occur *only* within the EAX register.

2. EDX
The EDX register is the *data register*, basically an extension of the EAX register, and it assists in storing extra data for more complex calculations like multiplication and division. It is most commonly used in conjunction with calculations performed with the EAX register.

3. ECX
**also called the *count register*, is used for looping operations.** An important point to understand is that **ECX counts downward, not upward.**
For example:
```python:n
counter = 0
while counter<10:
    print "Loop number: %d" % counter
    counter+=1
```
translate this code to assembly, ECX would equal 10 on the first loop, 9 on the second loop, and so on.


4. ESI & EDI
In x86 assembly, loops that process data rely on the ESI and EDI registers for efficient data manipulation. 

**The ESI register is the *source index* for the data operation and holds the location of the input data stream.**
**The EDI register points to the location where the result of a data operation is stored, or the destination index.**
***ESI is used for reading and EDI is used for writing.***

5. ESP & EBP
ESP and EBP registers are the *stack pointer* and the *base pointer*, respectively(分别地). These registers are used for managing function calls and stack pushed onto the stack and are followed by the return address. The ESP register points to the very top of the stack, and so it will point to the return address. The EBP register is used to point to the bottom of the call stack. In some circumstances a compiler may use optimizations to remove the EBP register as a stack frame pointer; in these cases the EBP register is freed up to be used like any other general-purpose register.

6. EBX
**The EBX register is the only register that was not designed for anything specific. It can be used for extra storage.**

7. EIP
This register points to the current instruction that is being executed. As the CPU moves through the binary executing code, EIP is updated to reflect the location where the execution is occurring.

>A debugger must be able to easily read and modify the contents of these registers. Each operating system provides an interface for the debugger to interact with the CPU and retrieve or modify these values. We'll cover the individual interfaces in the operating system-specific chapters.

# The Stack
The stack is a FILO (first in, last out) structure.
The ESP register is used to track the bottom of the stack frame. The stack grows from high memory addresses to low memory addresses.

![](~/18-13-32.jpg)

![](~/18-14-38.jpg)

![](~/18-16-44.jpg)
# Debug Events
When an event handler is called, the debugger halts and direction on how to continue. Some of the common events that a debugger must trap are these:
* Breakpoint hits
* Memory violations (also called access violations or segmentation faults)
* Exceptions generated by the debugged program

# Breakpoints
3 primary breakpoint types:
* soft breakpoints
* hardware breakpoints
* memory breakpoints

## Soft Breakpoints
used specifically to halt the CPU when executing instructions and are by far the most common type of breakpoints that you will use when debugging applications.

A soft breakpoint is a single-byte instruction that stops execution of the debugged process and passes control to the debugger's breakpoint exception handler. 

In order to understand how this works, you have to know the difference between an *instruction* and an *opcode* in x86 assembly.

An assembly instruction is a high-level representation of a command for the CPU to execute. Such as `MOV EAX, EBX`. This instruction tells the CPU to move the value stored in the register EBX into the register EAX. 
But the CPU does not know how to interpret that instruction; it needs it to be converted into something called an opcode. **An operation code, or opcode, is a machine language command that the CPU executes.**

Think of assembly instructions as the DNS of CPUs.

If the instruction we covered previously was at address 0x44332211, a common representation would look like this:
`0x44332211:    8BC3        MOV EAX, EBX`

This shows the address, the opcode, and the high-level assembly instruction.
In order to set a soft breakpoint at this address and halt the CPU, we have to swap out a single byte from the 2-byte 8BC3 opcode. This single byte represents the interrupt 3 (INT 3) instruction, which tells the CPU to halt. The INT 3 instruction is converted into the single-byte opcode 0xCC.
![](~/18-48-02.jpg)

![](~/18-47-55.jpg)


When the CPU comes skipping along and hits that byte, it halts, firing an INT3 event. 
Debuggers have the built-in ability to handle this event:
>When the debugger is told to set a breakpoint at a desired address, it reads the first opcode byte at the requested address and stores it. Then the debugger writes the CC byte to that address. When a breakpoint, or INT3, event is triggered by the CPU interpreting the CC opcode,the debugger catches it.The debugger then checks to see if the instruction pointer(EIP register) is pointing to an address on which it had set a breakpoint previously. If the address is found in the debugger's internal breakpoint list, it writes back the stored byte to that address so that the opcode can execute properly after the process is resumed.

![](~/18-59-30.jpg)

There are two types of soft breakpoints that can be set: one-shot breakpoints and persistent breakpoints.

Soft breakpoints have one caveat(弱点), however: **when you change a byte of the executable in memory, you change the running software's cyclic redundancy check (CRC) checksum. A CRC is a type of function that is used to determine if data has been altered in any way, and it can be applied to files, memory, text, network packets, or anything you would like to monitor for data alteration.**A CRC will take a range of values——in this case the running process's memory--and hash the contents. It then compares the hashed value against a known CRC checksum to determine whether there have been hanges to the data. If the checksum is different from the checksum that is stored for validation, the CRC check fails. This is important to note, **as quite often malware will test its running code in memory for any CRC changes and will kill itself if a failure is detected.** This is a very effective technique to slow reverse engineering and prevent the use of soft breakpoints, thus limiting dynamic analysis of its behavior.

## Hardware Breakpoints
**Useful When a small number of breakpoints are desired and the debugged software itself cannot be modified.**
Be set at the CPU level, in special registers called *debug registers*. A typical CPU has 8 debug registers (registers DR0 through DR7). Debug registers DR0 through DR3 are reserved for the addresses of the breakpoints. This means you can use only up to four hardware breakpoints at a time（同时最多4个断点）. Registers DR4 an DR5 are reserved, and DR6 is used as the status register, which determines the type of debugging event triggered by the breakpoint once it is hit. Debug register DR7 is essentically the on/off switch for the hardware breakpoints and also stores the different breakpoint conditions. By setting specific flags in the DR7 register, you can create breakpoints for the following conditions:
* Break when an instruction is executed at a particular address.
* Break when data is written to an address.
* Break on reads or writes to an address but not execution.

Figure 2-4 shows how the fields in DR7 are related to the hardware breakpoint behavior, length, and address.

Bits 0-7 are essentially the on/off switches for activatin breakpoints. The L and G fields in bits 0-7 stand for local and global scope. Bits 8-15 in DR7 are not used for the normal debugging purposes that we will be exercising. Refer to the Intel x86 manual for further explanation of those bits. Bits 16-31 determine the type and length of the breakpoint that is being set for the related debug register.
![](~/19-31-49.jpg)
 
Unlike soft breakpoints, which use the INT3 event, hardware breakpoints use interrupt 1 (INT1). The INT1 event is for hardware breakpoints and single-step events.

Limits: You can only set a breakpoint on a maximum of four bytes of data.
To solve this, you can have the debugger use memory breakpoints.

## Memory Breakpoint
When a debugger is setting a memory breakpoint, it is changing the permissions on a region, or page, of memory. A memory page is the smallest portion of memory that an operating system handles. 
Some examples of memory page permissions are these:
* Page execution    This enables execution but throws an access violation if the process attempts to read or write to the page.
* Page read         This enables the process only to read from the page; any writes or execution attempts cause an access violation.
* Page write        This allows the process to write into the page.
* Guard page        Any access to a guard page results in a one-time exception, and then the page returns to its original status.

Most operating systems allow you to combine these permissions, and has intrinsic functions that allow you to query the current memory permissions in place for a particular page and modify them if so desired.

The page permission we are interested in is the *guard page*, which is quite useful for such things as **separating the heap from the stack or ensuring that a portion of memory doesn't grow beyond an expected boundary, halting a process when it hits a particular section of memory.**

![](~/21-16-00.jpg)
