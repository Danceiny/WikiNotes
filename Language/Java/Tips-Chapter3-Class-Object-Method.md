# 在接口中不要存在实现代码
否则会鬼畜。


# 静态变量一定要先声明后赋值
```Java
static {
    i = 100;
}
public static int i = 1;
```
最后i=1。做到了先使用后赋值233333333
这是因为JVM会先找声明分配地址空间，然后再进行赋值。


# 不要Override静态方法
通过实例对象访问静态方法或静态属性不是好习惯。

# 构造函数尽量简化

# 避免在构造函数中初始化其他类

# 使用构造代码块精炼程序
分为
- 普通代码块
    > 方法后使用{}括起来的片段。

- 静态代码块
    > 在类中使用static修饰。

- 同步代码块
    > 使用synchronized修饰。表示同一时刻只能有一个线程进入该方法块中，是一种多线程保护机制。

- 构造代码块
    > 无任何前缀后缀，只是用{}括起来的片段。

**编译器会把构造代码块插入到每个构造函数的最前端。**

因此可以把构造代码块应用到如下场景：
1. 初始化实例变量（Instance Variable）
2. 初始化实例环境

使用构造代码块来计数实例，一个构造函数若调用了两次构造函数，编译器会智能地只插入一次构造代码块，因而不会出现重复计数的情形。


# 使用静态内部类提高封装性
静态内部类与普通内部类的区别：
1. 静态内部类不持有外部类的引用。（静态内部类只能访问外部类的静态方法和静态属性）
2. 静态内部类不依赖外部类。
3. 普通内部类不能声明static的方法和变量。（final static的常量还是可以的）

# 使用匿名类的构造函数

# 使用内部类实现多重继承
内部类可以继承一个与外部类无关的类。

# 避免对象的浅拷贝
一个类实现了Cloneable接口就具备了被拷贝的能力，再覆写clone()方法就会完全具备拷贝能力。拷贝在内存中进行，默认是浅拷贝。

# 推荐使用序列化实现对象的拷贝
实现序列化即可被深拷贝。

有一种更简单的方法就是使用Apache下的commons工具包中的SerializationUtils类。

# 覆写equals方法时不要识别不出自己
自反性问题。

# equals应该考虑null值情景

# 覆写equals使用getClass进行类型判断而不要使用instanceof

# 覆写equals方法必须覆写hashCode方法

# 推荐覆写toString方法
因为默认的打印出来看不懂233333

# package-info类

# 不要主动进行垃圾回收



**上一章：基本类型**
**下一章：字符串**
