# Sth
source:<程序员杂志201406 解密内存屏障 文/梁国栋>
platform: x86-64处理器+Linux

# 理解内存屏障
程序实际运行时可能并不完全按照开发者编写的顺序访问内存。
例如：
`x = r; y = 1;`

这里，y=1可能先于x=r执行。这就是内存乱序访问。

这种乱序访问行为出现的理由是为了提升程序运行时的性能。

编译器和CPU都可能引起内存乱序访问。

- 编译时，编译器优化进行指令重排；
- 运行时，多CPU间交互。

通常这不会有什么问题。但是尤其在多线程程序中，逻辑的正确性依赖于内存访问顺序，这时会带来错误。例如：
```c:n
// thread 1
while(!ok);
do(x);
// thread 2
x = 42;
ok = 1;
```

引入内存屏障来避免这种问题。

# 编译时内存乱序访问
g++等编译器若执行优化选项，则容易导致内存乱序访问。避免之可使用编译器屏障，又称优化屏障。

Linux内核提供了函数barrier()。使用示例：
```c:n
//test.cpp
int x,y,r;
void f()
{
	x = r;
	__asm__ __volatile__("" ::: "memory");	//barrier
	y = 1;
}
```
这样就不会发生内存乱序访问了。

这里也可以修改x和y的定义来解决问题：
`volatile int x,y;`

使用volatile关键字，使得x相对y、y相对x在内存访问上有序。

由于内核中：（一个类型转换而已啦）
`#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))`

所以还有一种解决方案：
```int x,y,r;
void f()
{
	ACCESS_ONCE(x) = r;
	ACCESS_ONCE(y) = 1;
}
```

# 运行时内存乱序访问
单CPU不会。多CPU有cache，涉及读取内存数据，故可能存在内存乱序访问。
