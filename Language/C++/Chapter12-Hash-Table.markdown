---
date: 2016-01-18 20:01
status: public
title: Chapter12-Hash-Table
---

需要实现的置换表需要满足：
1. 查找记录中的节点数据时速度要非常快，最好是类似于随机存取。
2. 将节点数据放入记录的速度也要非常快。这意味着数据项插入的过程不可有数据移动排序等费时费力操作。
3. 要能在有限的存储空间内进行。
哈希表可满足以上。

## hash struct
定义哈希数组如下：
```C:n
struct HASHITEM{
    int64 checksum;//64位哈希值，用以验证表中数据是否是要找的局面
    int depth;//该表项求值时的搜索深度
    //表项值的类型
    enum { exact, lower_bound, upper_bound } entry_type;
    double eval;//所代表的节点的值
    }hashtable[HASH_TABLE_SIZE];
    //定义大小为HASH_TABLE_SIZE的哈希数组
```
对要搜索的每一节点，计算出它的一个哈希值(hashIndex,通常是一个32位数对哈希表大小取模)以确定此局面在哈希表中的位置。计算另一个哈希值(Checksum)来校验表中的数据项是否是要找的那一项。通常这是一个64位数。

在对某一局面搜索之前，先查看哈希表项hashTable[hashIndex]，如果hashTable[hashIndex],checksum == Checksum并且hashTable[hashIndex].depth大于等于最大搜索深度减去当前层数，就返回hashTable[hashIndex].eval作为当前局面的估值。

## hash-alpha-beta
下面的伪代码示意了如何使用置换表与Alpha-Beta搜索协同工作：
```C:n
int alphabeta(int depth, int alpha, int beta)
{
    int value, bestvalue = -INFINITY;
    int hashvalue;
    if(game over or depth <= 0)return evaluation();//胜负已分或者叶节点，返回估值
    //查看置换表中有无当前节点数据
    if(lookup(depth,&alpha,&beta,&hashvalue))return hashvalue;//有则直接返回
    for(each possible move m)//对下一步每一可能的走法m
    {
        make move m;
        //递归搜索的子节点
        value = -alphabeta(d-1, -beta, -localalpha);
        unmake move m;
        if(value > bestvalue)bestvalue = value;//保留最佳值
        if(bestvalue >= beta)break;//beta剪枝
        if(bestvalue > alpha)alpha = bestvalue;//修改alpha范围
    }
    //将搜索过的结果存入置换表
    store(depth, bestvalue, alpha, beta);
    return bestvalue;
}
```
    
## 基于哈希的置换表的应用问题

1. 清除哈希表
哈希表不需要在每次搜索前清空。
当同一哈希地址上要插入第二个哈希表项时，只要64位哈希值不同，也就是说不是同一节点。如果发生冲突，则后面的将覆盖前面的。
2. 哈希表的层次
在哈希表项结构定义中，记录了该表项被搜索记录时的搜索深度。     
同一局面在搜索树的不同层次上出现，如果哈希表中记录了某一个节点的值，但当前要搜索的相同节点的层次不同。
这时，如果哈希表中的节点层次较待搜索的节点低，即更为靠近叶节点，则应当进行搜索并将搜索结果覆盖到哈希表中。
如果哈希表中的节点层次较待搜索的节点高，即更靠近根节点，则应直接引用哈希表中数据。
普遍认为层次越高的节点其求值精度越高。
3. 叶节点
对围棋等估值函数复杂，估值过程时间长的棋类来说，对叶子节点进行哈希处理，可提高性能。
对象棋等棋类，应视估值函数的运算时间而定。
搜索的最大深度越大，哈希表的命中率越高，相对于每个节点都要执行查找、插入操作的时间花费而言，提升越明显；
搜索的最大深度很浅时，哈希表的命中率不高，此时对叶子节点进行哈希操作不一定能提高搜索速度。
如果估值函数很快，则没有必要对叶节点进行哈希处理。
在这本书的范例程序中，估值函数速度较慢，故对叶节点进行了哈希处理。
4. 散列度
散列程度高，冲突少的哈希函数性能更高。
影响散列度的主要因素之一是求哈希值的方法。
Zobrist哈希技术是一种在博弈程序中广为使用的随机哈希方法，兼顾了速度和散列度。
5. 尺寸
在均匀程度相同的情形下，哈希表尺寸越大，则散列度越好，冲突越少，性能越佳。
但是哈希数组的定义不应超过物理内存的大小。一旦使用虚存（？），哈希表的操作速度将大幅度降低。
对于相同搜索深度而言，哈希表的大小与性能的关系并不是线性的。
6. 解决冲突
解决冲突有以下几方面的不利因素：
* 同全部可能的局面相比，哈希表尺寸很小，如果解决冲突，可能几次搜索就导致哈希表的空间耗尽，从而使哈希操作的效率大幅降低。
* 如果动态申请内存空间，则面临内存上的大量消耗，并且申请内存时所需的大量时间将导致性能进一步下降。
* 由于开局时的哈希数据对中盘及残局几乎没有帮助，在哈希表中解决冲突将导致大量数据冗余（？），从而降低效率。
* 依赖高散列度的哈希方法配合足够大小的哈希表，可以取得足够低的冲突率。

