1.不能重载下面的运算符(~无意义,:为中文解释符,;无意义)
~sizeof:sizeof运算符;
~.:成员运算符;
~.*:成员指针运算符;
~:::作用域解析符;
~?::条件运算符;
~typeid:一个RTTI运算符;
~const_cast:强制类型转换运算符;
~dynamic_cast:强制类型转换运算符;
~reinterpret_cast:强制类型转换运算符;
~static_cast:强制类型转换运算符;

2.下面的运算符只能通过成员函数进行重载
~=:赋值运算符;
~():函数调用运算符;
~[]:下标运算符;
~->:通过指针访问类成员的运算符;

3.
类型转换:
\只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型.
\被称为转换函数的特殊类成员运算符函数,用于将类对象转换为其他类型.转换函数是类成员,没有返回类型,没有参数,名为operator typename(),其中typename是对象将被转换成的类型.将类对象赋给typename变量或将其强制转换为typename类型时,该转换函数将自动被调用.

4.如果在构造函数中使用new来初始化指针成员,则应在析构函数中使用delete.如果有多个构造函数,则必须以相同的方式使用new(带不带[]),因为只有一个析构函数,所有的构造函数必须与它兼容.然而,可以在一个构造函数中使用new初始化指针,在另一个构造函数中将指针初始化为空(0或者C++中的nullptr),这是因为delete(带或者不带)可以用于空指针.

5.在下述情况下析构将被调用:
-如果对象是动态变量,则当执行完定义该对象的程序块时,将调用该对象的析构函数.
-如果对象是静态变量(外部.静态.静态外部.或来自名称空间),则在程序结束时将调用对象的析构函数
-如果对象 是用new创建的,则只有显示使用delete删除对象时,其析构函数才会被调用.

6.只有构造函数可以使用"初始化列表"语法.
成员初始化列表由逗号分隔的初始化列表组成(前面带冒号).位于参数列表的右括号)之后,函数体左括号{之前.
如果classy是一个类,mem1.mem2和mem3是这个类的数据成员,则类构造函数可以如下初始化数据成员:
classy::classy(int n,int m):mem1(n),mem2(0),mem3(n*m+2)
{///}
将mem1初始化为n,将mem2初始化为0,...注意一下几点:
=必须用这种格式来初始化非静态const数据成员
=必须用这种格式来初始化引用数据成员
=不能将此语法用于构造函数之外的其他类方法
