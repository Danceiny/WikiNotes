---
date: 2016-02-07 17:29
status: public
title: 线性空间滤波
---

# 线性空间滤波
执行线性空间滤波时，有两个意义相近的概念。一个是 **相关**， 另一个是 **卷积**。
>相关是指掩模w按下图所示方式在图像f中移动的过程。
技术上说，卷积是相同的过程，只是在图像f中移动w前，要将w旋转180°。（反褶）
![](~/17-29-38.jpg)

工具箱使用函数imfilter来实现线性空间滤波：
`g = imfilter(f, w, filtering_mode, boundary_options, size_options)`
其中，f 是输入图像，w 为滤波掩模，g 为滤波结果。filtering_mode用于指定在滤波过程中是使用相关`'corr'`还是卷积`'conv'`。boundary_options用于处理边界充零问题，边界的大小由滤波器的大小确定。size_options可以是'same'或'full'。

函数imfilter的通用语法为`g = imfilter(f,w, 'replicate')`

在实现IPT标准线性空间滤波时用到该语法。

>已知对旋转过的滤波器执行 **相关** 操作与对原始滤波器进行 **卷积** 操作是相同的。若滤波器关于其中心对称，则两个选项将产生同样的结果。

![](~/17-42-40.jpg)

![](~/17-41-55.jpg)

在使用预先旋转的滤波器或对称的滤波器时，希望执行卷积计算。有两种方法：
1. `g = imfilter(f, w, 'conv', 'replicate')`
2.  `rot90(w, 2)`将w旋转180°，然后`imfilter(f, w, 'replicate')`。

滤波后的图像的每个元素使用双精度浮点算术进行计算。但是imfilter会输出图像转换为与输入图像相同的类。
>若f是一个整数数组，则输出中超过整型范围的元素被截断，且小数部分四舍五入。若结果要求更高精度，则f需要在使用函数imfilter之前利用iim2double或double转换为double类。

# 非线性空间滤波
线性空间滤波基于计算乘积之和，这是一个线性操作；而非线性空间滤波则基于非线性操作。例如，令每个中心点处的响应等于其邻域内的最大像素值的操作即为非线性滤波。

函数colfilt以列的形式组织数据。
函数nlfilter直接执行二维操作，占用更多内存，但是执行速度更快，因此更多采用nlfilter。

给定一个大小为M x N的图像f和一个m x n的邻域，函数colfilt生成一个最大尺寸为mn x MN的矩阵A（ **A总有mn行，但列数可根据输入的尺寸变化，尺寸的选择由colfilt自动完成。**），在该矩阵中，每一列对应于其中心位于图像内某个位置的邻域所包围的像素。
`g = colfilt(f, [m n], 'sliding', @fun, parameters)`
m,n是滤波区域的维数，'sliding'表示处理过程是在输入图像f中逐个像素地滑动该滤波区域，@fun引用一个函数，将该函数任意表示为fun，parameters表示fun可能需要的参数（用逗号分隔开），@是函数句柄，一种MATLAB数据类型。

基于A的组织形式，函数fun必须对每一列操作，并返回一个包含所有列的结果的行向量v。v的第k个元素是对A的第k列进行fun操作后的结果。因而A最大可以有MN列，v的最大维数是1 x MN。

## 输入图像填充padarray
在使用colfilt时，在进行滤波之前，输入图像必须经过了填充。
`fp = padarray(f, [r c], method, direction)`
其中，f为输入图像，fp为填充后的图像，[r c]用于给出填充的行数和列数（即多出来的行列数）。
>method有：
1. 'symmetric'  图像大小通过围绕边界进行镜像反射来扩展；
2. 'replicate' 图像大小通过复制外边界中的值来扩展；
3. 'circular'  图像大小通过将图像看成是一个二维周期函数的一个周期来扩展。
**默认用0填充。**

>direction有：
1. 'pre'  在每一维的第一个元素前填充；
2. 'post'  在每一维的最后一个元素后填充；
3. 'both'  在每一维的第一个元素前和最后一个元素后填充。为默认值。

## 使用函数colfilt实现非线性空间滤波
执行这样的一个非线性滤波：在任何点处的响应都是中心在该点的邻域内的像素亮度值的几何平均。大小为m x n的邻域中的几何平均是邻域内亮度值的乘积的1/mn次幂。
首先执行非线性滤波函数，调用gmean。
```MATLAB:n
function v = gmean(A)
mn = size(A, 1); % The length of the columns of A is always mn.
v = prod(A, 1).^(1/mn);
```
为削减边界效应，在函数padarray中使用'replicate'选项来填充输入图像：
`>> f = padarray(f, [m n], 'replicate');`
最后调用函数colfilt：
`>> g = colfilt(f, [m n], 'sliding', @gmean);`

>应当注意到，尽管矩阵A是函数gmean中的一个参量，但它并未包括在函数colfilt的参数中。这个矩阵可通过在函数colfilt中使用函数句柄自动传递给gmean。
由于A是由colfilt自动管理的，所以A的列数是可变的（但是行数总是mn）。
因此，函数colfilt每调用该参量一次，就要计算一次A的大小。这种情况下，滤波的过程就是计算邻域内所有像素的乘积的1/mn次幂。
对于(x,y)的任意值，该点的滤波结果包含在v的某列中。通过句柄@来识别的函数可以是任何能从创建该函数句柄的位置调用的函数。
关键要求是函数在A的列上进行操作，并返回一个包含了所有单独列的结果的行向量。
函数colfilt获得这些结果，并重新排列，以产生输出图像g。

函数colfilt仍然是进行非线性滤波操作的最好选择。
