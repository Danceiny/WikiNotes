
 ![](http://opkk27k9n.bkt.clouddn.com/17-7-5/70708206.jpg)
17日志：
1. 协助队友完成了按键实验的第一份流程图。我们首先考虑的是对我们”设计者“最”友好“的理想情况，因而对用户的行为限定过多，对按键速度要求过于严苛，对按键行为宽容度很低，因此出现了很多漏洞，如果照此实现后将非常难实现预期效果。此外由于我们在设计流程图时最开始对于去抖也有一个假定前提，即完成去抖后再进行。初步完成后计划在中断中再使用定时器或者软件延时完成去抖，经老师提醒后，我意识到这是一个非常蠢的办法，这样CPU的空闲比例将非常低，很有可能一直处于忙碌状态。

2. 在听取了其他部分组的流程图后，一直在考虑如何为我们的”简易”的程序设计一个简单而且可扩展的流程框架，以便加上定时、双击单击判断等功能。不过很容易陷入一个增设变量、增设判断的怪圈，导致流程异常复杂且不符合“人类思维定势“，一下子就把自己也给绕进去了。下午在老师讲解完后，有一种恍然大悟的感觉。晚上根据P_CNT和R_CNT的方法，重构了流程图。感觉很简化，易于理解。

3. 下午完成了按键的焊接。第一次焊接完毕后利用数码管显示来检验按键焊接是否准确无误，出现了部分错误。仔细对比按键原理图发现是焊错了三个点，又返回重焊。再次完成后又继续测试，发现还是有几个错误。但是焊接点已经没有错误，考虑到焊接点非常密，我手法又不好，所以开始排查短路和断路，特别是短路。对可疑的几个短路断路点，我又补焊、修复了一下，最后基本确认所有键位都是正常工作的。

18日志：
1. 昨晚到今天早上完成了用P_CNT和R_CNT进行按键扫描和判断的流程图，其中扫描和判断是一体的，一个定时器周期就扫描一轮，一轮扫描就判断一轮。（注：10个按键分为4轮）
关键判断点有：
稳定按下状态时判断是否为长按；
刚按下（已去抖）时判断是否为双击；
稳定松开状态时判断是否为单击；

关键判断依据有：
If(p==2)
{
If(R<DOUBLE)
{double click committed.}
R = 0
}
 
If(R==2)
{
If((P>LONG)
{R = 200;//init}
P = 0
}

主要设计参数有：
TMR0：10ms
每个键对应一个Ri，Pi，分别全局初始化为Ri=200，Pi=0；
【双击延时】= 300ms，DOUBLE=30；
【长按延时】=2000ms，LONG=200；
键盘IO为RC0-RC3，弱上拉；

2. 郭毅远给我提供了一份简单且可正常工作的扫描测试显示代码，阅读后发现与我的程序框架有区别。这份代码扫描和判断是分开的，四轮扫描完成后将按下的情况交给判断部分处理，对松开状态不予处理。而我的流程图大部分判断是针对松开状态（因为大部分情况下松开的按键占据绝大多数），一个定时器周期只扫描一轮。
此时我忘记了钟sir的忠告，没有重画流程图就开始写程序，没有重视已有的代码框架与我原本的流程图的差异性。下午晚饭前代码基本完成，但是首先就碰到了数码管不正常显示的情形，花了比较常时间才解决。然后发现判断结果还是不能显示出来，重审代码又修修补补，也还没有调试好。此时比较晚了我开始对着代码画流程图，还没有对流程图进行严格的逻辑审查。

3. 这次的代码量特别大，而且有很多基本一样的代码，为了提高可复用性，我第一次用到了函数。刚开始对汇编的函数写法和用法以及注意事项都不了解，对函数代码在文件中应该摆放的位置也不知道，还是通过编译报错发现并纠正的。但是在不清楚函数调用可能造成的“效应”情况下，使用函数可能造成程序逻辑无误的情况下出现意外的错误。特别纠结了很久函数传参的问题。

4. 申请的变量太多，事先没有详细规划，往往是需要用到就到asm最前面去开一个。后来出现了占用内存超标的情况导致的编译错误：section 'SHAREVARIABLE' can not fit the section.。于是又把变量挪一个位置，就解决了。

5. 这次实验历时两天多，虽然最后我也没有实现预期效果，但是自我感觉画程序流程图的意识和水平都提高了不少，对汇编代码的结构也有了认识上的较大提高~~~~