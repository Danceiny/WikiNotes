在为嵌入式系统和其他计算机平台写程序时有一个最基本的区别，就是嵌人式程序总是以一个无限循环作为结束。

 C/C++ 程序的启动代码通常包含以下行为，并且按照所列的次序执行：
1 、禁止所有中断。
2 、从 ROM  里复制所有初始化数据到 RAM  里。
3 、把未初始化数据区清零。
4 、为堆栈分配空间并初始化。
5 、初始化处理器堆栈指针。
6 、创建并初始化堆。
7 、（只对 C++ 有效）对所有全局变量执行构造函数和初始化函数。
8 、允许中断。
9 、调用 main 。
![](http://opkk27k9n.bkt.clouddn.com/17-7-5/44954371.jpg)
因为启动代码不是自动插入的，程序员通常必须亲自汇编这段代码并把得到的目标文件包括在链接器的输入文件列表里。他甚至需要给链接器一个特殊的命令行选项以阻止它插入通常的启动代码。适用于多种目标处理器的启动代码可以在可以在 GNU  软件包 libgloss  中找到。

所有以下划线开始的名字（比如_TopOfStack）是可以从你的源代码内部引用的变量。

---
date: 2016-04-03 15:20
status: public
title: FAT32文件系统
---

# 硬盘的性能指标
1.转速
2.数据传输率
3.缓存
4.平均寻道时间
5.柱面切换时间
6.平均潜伏期（与转速成反比）
7.平均方位时间

# 寻址方式
1、CHS
Cylinder柱面，Head磁头，Sector扇区
2、LBA
Logic Block Address逻辑块地址，又称线性寻址模式

# 数据存储格式
1. Big-endian
2. Little-endian

# 1.建立文件
假设现在有一个子目录，它的名字是“smart monkey”，我们要在其下建立一个文件“yatou.txt”。
使用的文件系统为 FAT32，簇大小为 4096 字节，我们要建立的文件大小为 5000 个字节。
步骤 1：读取位于卷 0 号扇区的引导扇区，根据引导扇区中的信息定位 FAT 表、数据区和根目录的位
置。
步骤 2：遵照“smart monkey”的位置。查看根目录下的每个目录项，寻找名字为“smart monkey”
且具有目录属性的目录项。找到后，查看它的起始簇号为 3。
  步骤 3：读取 smart monkey 的起始簇（3 号簇）的内容，查找每个目录项，直到找到一个为分配的目录项。
步骤 4：找到可用项后写入文件名“yatou.txt”，并将文件大小和当前时间写入相应的位置。
步骤 5：为文件内容分配簇空间。转到 FAT 表，寻找空闲的位置。发现 4 号 FAT 表项未使用，这就说
明 4 号簇是空闲的。将 4 号簇分配给文件，并在 4 号簇的 FAT 表项内写入结束标记。
步骤 6：将簇号 4 写入文件目录项的起始簇号区域。将文件的钱 4096 字节写入到 4 号簇中，还剩下
904 字节，所以还需要再为其分配一个簇。
步骤 7：在 FAT 表中继续寻找为分配簇，找到 5 号簇为空闲未使用（因其 FAT 表项为 0）。
步骤 8：将文件第一簇（即 4 号簇）的 FAT 表项值改写为 5，将文件的最后 904 字节写入 5 号簇。
步骤 9：在 5 号簇的 FAT 表项内写入结束标记。

# 2.删除文件
现在我们将前面例子中建立的“smart monkey\yatou.txt”文件删除。
步骤 1：从卷 0 号扇区读取引导扇区，根据引导扇区中的信息定位 FAT 表、数据区和根目录的位置。
步骤 2：在根目录下寻找名字为“smart monkey”且具有目录属性的目录项。
  步骤 3：由“smart monkey”的目录项中获取它的起始簇号为 3，到 3 号簇查看“smart monkey”的内容，从中找到文件“yatou.txt”的目录项，提取出它的起始簇号，为 4 号簇。
步骤 4：到 FAT 表中找到该文件的簇链，确定他飞存储位置为 4 号簇和 5 号簇。步骤 5：将 4 号簇和 5 号簇的 FAT 项设置为 0.
  步骤 6：将文件“yatou.txt”的目录项的第一个字节改为 0xE5。


要实现四位数码管的滚动效果，考虑到有个段选的刷新频率，还有一个滚动的频率，因此首先想到要用到两个计时器分别计时。比如让timer0计刷新频率，定时5ms，让timer1计滚动频率，定时500ms。
不过两个定时器处理的事务有交叉部分，如果在需要更新数据的时候，即需要开始滚动的时候，两个中断没有同时触发，则可能导致异步误差的累积，影响最终实现效果。而且在设计构想中，这种方式似乎也不太好实现。
于是想到要做一个计数，让数码管稳定地显示四个数字一段时间，而后再更新这四个数字，这样就能比较简单且效果明显地实现滚动。在实现这一步后，我们打算做一个中断闪烁（四位同时闪烁）效果，简单地加入一个Timer0定时器，在检测到电平中断发生后，禁掉电平中断，暂停Timer1中断，开启Timer0，进入Timer0控制的闪烁状态。

下载代码后，期望的闪烁状态并未出现，而是在电平中断后数码管熄灭一段时间后重新开始滚动。使用软件仿真观察发现，是Timer0的定时循环中对Timer1的中断没有较好控制。重构代码后，数码管可以在中断发生时闪烁。



 ![](http://opkk27k9n.bkt.clouddn.com/17-7-5/70708206.jpg)
17日志：
1. 协助队友完成了按键实验的第一份流程图。我们首先考虑的是对我们”设计者“最”友好“的理想情况，因而对用户的行为限定过多，对按键速度要求过于严苛，对按键行为宽容度很低，因此出现了很多漏洞，如果照此实现后将非常难实现预期效果。此外由于我们在设计流程图时最开始对于去抖也有一个假定前提，即完成去抖后再进行。初步完成后计划在中断中再使用定时器或者软件延时完成去抖，经老师提醒后，我意识到这是一个非常蠢的办法，这样CPU的空闲比例将非常低，很有可能一直处于忙碌状态。

2. 在听取了其他部分组的流程图后，一直在考虑如何为我们的”简易”的程序设计一个简单而且可扩展的流程框架，以便加上定时、双击单击判断等功能。不过很容易陷入一个增设变量、增设判断的怪圈，导致流程异常复杂且不符合“人类思维定势“，一下子就把自己也给绕进去了。下午在老师讲解完后，有一种恍然大悟的感觉。晚上根据P_CNT和R_CNT的方法，重构了流程图。感觉很简化，易于理解。

3. 下午完成了按键的焊接。第一次焊接完毕后利用数码管显示来检验按键焊接是否准确无误，出现了部分错误。仔细对比按键原理图发现是焊错了三个点，又返回重焊。再次完成后又继续测试，发现还是有几个错误。但是焊接点已经没有错误，考虑到焊接点非常密，我手法又不好，所以开始排查短路和断路，特别是短路。对可疑的几个短路断路点，我又补焊、修复了一下，最后基本确认所有键位都是正常工作的。

18日志：
1. 昨晚到今天早上完成了用P_CNT和R_CNT进行按键扫描和判断的流程图，其中扫描和判断是一体的，一个定时器周期就扫描一轮，一轮扫描就判断一轮。（注：10个按键分为4轮）
关键判断点有：
稳定按下状态时判断是否为长按；
刚按下（已去抖）时判断是否为双击；
稳定松开状态时判断是否为单击；

关键判断依据有：
If(p==2)
{
If(R<DOUBLE)
{double click committed.}
R = 0
}
 
If(R==2)
{
If((P>LONG)
{R = 200;//init}
P = 0
}

主要设计参数有：
TMR0：10ms
每个键对应一个Ri，Pi，分别全局初始化为Ri=200，Pi=0；
【双击延时】= 300ms，DOUBLE=30；
【长按延时】=2000ms，LONG=200；
键盘IO为RC0-RC3，弱上拉；

2. 郭毅远给我提供了一份简单且可正常工作的扫描测试显示代码，阅读后发现与我的程序框架有区别。这份代码扫描和判断是分开的，四轮扫描完成后将按下的情况交给判断部分处理，对松开状态不予处理。而我的流程图大部分判断是针对松开状态（因为大部分情况下松开的按键占据绝大多数），一个定时器周期只扫描一轮。
此时我忘记了钟sir的忠告，没有重画流程图就开始写程序，没有重视已有的代码框架与我原本的流程图的差异性。下午晚饭前代码基本完成，但是首先就碰到了数码管不正常显示的情形，花了比较常时间才解决。然后发现判断结果还是不能显示出来，重审代码又修修补补，也还没有调试好。此时比较晚了我开始对着代码画流程图，还没有对流程图进行严格的逻辑审查。

3. 这次的代码量特别大，而且有很多基本一样的代码，为了提高可复用性，我第一次用到了函数。刚开始对汇编的函数写法和用法以及注意事项都不了解，对函数代码在文件中应该摆放的位置也不知道，还是通过编译报错发现并纠正的。但是在不清楚函数调用可能造成的“效应”情况下，使用函数可能造成程序逻辑无误的情况下出现意外的错误。特别纠结了很久函数传参的问题。

4. 申请的变量太多，事先没有详细规划，往往是需要用到就到asm最前面去开一个。后来出现了占用内存超标的情况导致的编译错误：section 'SHAREVARIABLE' can not fit the section.。于是又把变量挪一个位置，就解决了。

5. 这次实验历时两天多，虽然最后我也没有实现预期效果，但是自我感觉画程序流程图的意识和水平都提高了不少，对汇编代码的结构也有了认识上的较大提高~~~~