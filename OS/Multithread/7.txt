4.5.5确定LWP的已空闲时间
    如果活动线程的数量减少，LWP池中的一些LWP将不再被需要。如果LWP的数量比活动
的线程多，线程库破坏那些没有用的LWP。线程库确定LWP的空闲的时间--如果线程在
足够长的时间内没有被使用（现在的设置是5分钟），它们将被删除。

4.6扩展传统的信号
    为了适应多线程，UNIX的信号模型以一种相当自然的方式被扩展。信号的分布是用
传统机制建立在进程内部的（signal(2),sigaction(2), 等等）。
    如果一个信号控制器被标志为SIG_DFL或者SIG_IGN，在收到信号后所采取的行动
（exit, core dump, stop, continue, or ignore）在整个接收进程中有效，将影响到
进程中的所有线程。关于信号的基本信息请参见signal(5)。
    每个线程有它自己的信号掩模。如果线程使用的内存或其他状态也在被信号控制
器使用，线程会关于一些信号阻塞。进程中所有的线程共享由sigaction(2)和其变量
建立的信号控制器，？？？象通常那样。
    进程中的一个线程不能给另一个进程中的线程发送信号。一个由kill(2)和sigsend
(2)送出的信号是在进程内部有效的，将被进程中的任何一个接收态的线程接收并处理。
    非绑定线程不能使用交互的信号栈。一个绑定线程可以使用交互信号栈，因为其
状态是和执行资源连接的。一个交互信号栈必须通过sigaction(2) ，以及sigaltstack
(2)来声明并使能。
    一个应用程序给每个进程一个信号控制器，在它的基础上，每个线程都有线程信
号控制器。一种办法是给在一张表中给每个线程控制器建立一个索引，由进程信号控制
器来通过这张表实现线程控制器。这里没有零线程。
    信号被分为两类：陷阱（traps）和意外(exceptions，同步信号)和中断
（interrupts，异步信号）。
    在传统的UNIX中，如果一个信号处于挂起状态（即等待接收），发生的其他同样的
信号将没有效果--挂起信号由一位来表示，而不是一个计数器。
    就象在单线程的进程里那样，如果一个线程在关于系统调用阻塞时收到一个信号，
线程将提前返回，或者带有一个EINTR错误代码，或者带有比请求少的字节数（如果阻
塞在I/O状态）。
    对于多线程编程有特殊意义的是作用在cond_wait(3T)上的信号的效果。这个调用
通常在其他线程调用cond_signal(3T)和cond_broadcast(3T)，但是，如果等待线程收
到一个UNIX信号，将返回一个EINTR错误代码。更多的信息参见"对于条件变量的等待中
断"。

4.6.1同步信号
    陷阱（例如SIGILL, SIGFPE, SIGSEGV）发生在线程自身的操作之后，例如除零
错误或者显式地发信号给自身。一个陷阱仅仅被导致它的线程类控制。进程中的几个
线程可以同时产生和控制同类陷阱。
    扩展信号到独立线程的主张对于同步信号来说是容易的--信号被导致问题的线程
来处理。然而，如果一个线程没有处理这个问题，例如通过sigaction(2)建立一个信号
控制器，整个进程将终止。
    因为一个同步信号通常意味着整个进程的严重错误，而不只是一个线程，终止进程
通常是一个明智的做法。

4.6.2异步信号
    中断（例如SIGINT和SIGIO）是与任何线程异步的，它来自于进程外部的一些操作。
它们也许是显式地送到其他线程的信号，或者是例如Control-c的外部操作，处理异步
信号不处理同步信号要复杂的多。
    一个中断被任何线程来处理，如果线程的信号掩模允许的话。如果有多个线程可以
接收中断，只有一个被选中。
    如果并发的多个同样的信号被送到一个进程，每一个将被不同的线程处理，如果
线程的信号掩模允许的话。如果所有的线程都屏蔽该信号，则这些信号挂起，直到有信
号解除屏蔽来处理它们。

4.6.3连续语义（Continuation Semantics）
    连续语义（Continuation Semantics）是处理信号的传统方法。其思想是当一个
信号控制器返回，控制恢复到中断前的状态。这非常适用于单线程进程的异步信号，如
同在示例4-1中的那样。在某些程序设计语言里（例如PL/1），这也被用于意外
（exception）处理机制。
        Code Example 4-1 连续语义
        Unsigned int nestcocunt;
        Unsigned int A(int i, int j) {
                Nestcount++;
                If(i==0)
                        Return (j+1);
                Else if (j==0)
                        Return (A(I-1,1));
                Else
                        Return (A(I-1,A(I, j-1)));
        }
        void sig(int i){
                printf("nestcount=%d\n",nestcount);
        }
        main(){
                sigset(SIGINT, sig);
                A(4,4);
        }

4.6.4对于信号的新操作
    对于多线程编程的几个新的信号操作被加入操作系统。
        Thr_sigsetmask(3T)
    Thr_sigsetmask(3T)针对线程而sigprocmask(2)针对进程--它设置（线程）的
信号掩模。如果一个新线程被创建，它的初始信号掩模从父线程那里继承。
    在多线程编程中避免使用sigprocmask()，因为它设置LWP的信号掩模，被这个
操作影响的线程可以在一段时间后改变。？？？
    不象sigprocmask()，thr_sigsetmask()是一种代价相对低廉的调用，因为它不
产生系统调用。
        Thr_kill(3T)
        Thr_kill是kill（2）的线程版本--它发送信号给特定的线程。
    当然，这与发送信号给进程不同。如果一个信号被发送给进程，信号可以被进
程中的任何线程所控制。一个由thr_kill()发出的信号只能被指定的线程处理。
    注意，你只能用thr_kill()给当前进程里的线程发信号。这是因为线程标识符
是本地的--不可能给其他进程内的线程命名。
        Sigwait(2)
    Sigwait(2)导致调用线程阻塞直到收到set参数指定的所有信号。线程在等待时，
被set标识的信号应当被解除屏蔽，但最初的信号掩模在调用返回时将恢复。
    用sigwait()来从异步信号当中把线程分开。你可以创建一个线程来监听异步信
号，而其它线程被创建来关于指定的异步信号阻塞。
    如果信号被发送，sigwait()清除挂起的信号，返回一个数。许多线程可以同时
调用sigwait()，但每个信号被收到后只有相关的一个线程返回。
    通过sigwait（）你可以同时处理异步信号--一个线程通过简单的sigwait()调用
来处理信号，在信号一旦被受到就返回。如果保证所有的线程（包括调用sigwait()
的线程）屏蔽这样的信号，你可以保证这样的信号被你指定的线程安全地处理。
    通常，用sigwait()创建一个或多个线程来等待信号。因为sigwait()可以接收
被屏蔽的信号，应当保证其它线程对这样的信号不感兴趣，以免信号被偶然地发送给
这样的线程。如果信号到达，一个线程从sigwait()返回，处理该信号，等待其它的
信号。处理信号的线程不限于使用异步安全函数，可以和其它线程以通常的方式同
步（异步安全函数类型被定义为"安全等级的MT界面MT Interface Safety Levels）。
---------------------------------------
注意-sigwait()不能用于同步信号
---------------------------------------
        sigtimedwait(2)
        sigtimedwait(2)类似于sigwait(2)，不过如果在指定时间内没有收到信号，
它出错并返回。

4.6.5面向线程的信号（thread-directed signals）
    UNIX信号机制扩展了一个叫做"线程引导信号"的概念。它们就象普通的异步信
号一样，只不过他们被送到指定线程，而不是进程。
    在单独的线程内等待信号比安装一个信号控制器安全和容易。
    处理异步信号的更好的办法是同时处理它们。通过调用sigwait(2)，一个线程
可以等待一个信号发生。
        Code Example 4-2 异步信号和sigwait(2)
        Main(){
                Sigset_t set;
                Void runA(void);
                Sigemptyset(&set);
                Sigaddset(&set, SIGINT);
                Thr_sigsetmask(SIG_BLOCK, &set, NULL);
                Thr_create(NULL, 0, runA, NULL, THR_DETACHED, NULL);
                While(1){
                        Sigwait(&set);
                        Printf("nestcount=%d\n",nestcount);
                }
        }
        void runA(){
                A(4,4);
                Exit(0);
        }
    这个例子改变了示例4-1：主函数屏蔽了SIGINT信号，创建了一个子线程来调
用前例中的函数A，然后用sigwait来处理SIGINT信号。
    注意信号在计算线程中被屏蔽，因为计算线程继承了主线程的信号掩模。除非
用sigwait()阻塞，主线程不会接收SIGINT。
    而且，注意在使用sigwait()中，系统调用不会被中断。

4.6.6完成语义（Completion Semantics）
    处理信号的另外一种办法是用完成语义。完成语义使用在信号表明有极严重的
错误发生，以至于当前的代码块没有理由继续运行下去。该代码将被停止执行，取
而代之的是信号控制器。换句话说，信号控制器完成代码块。
    在示例4-3中，有问题的块是if语句的then部分。调用setjmp(3C)在jbuf中保
存寄存器当前的状态并返回零--这样执行了块。
        Code Example 4-3 完成语义
        Sigjmp_buf  jbuf;
        Void mult_divide(void) {
                Int a,b,c,d;
                Void problem();
                Sigset(SIGFPE, problem);
                While(1) {
                        If (sigsetjmp(&jbuf) ==0) {
                                Printf("three numbers, please:\n");
                                Scanf("%d %d %d", &a,&b,&c);
                                D=a*b/c;
                                Printf("%d*%d/%d=%d\n",a,b,c,d);
                        }
                }
        }
        void problem(int sig){
                printf("couldn't deal with them,try again\n");
                siglongjmp(&jbuf,1);
        }
    如果SIGFPE（一个浮点意外）发生，信号控制器被唤醒。
    信号控制器调用siglongjmp(3C)，这个函数保存寄存器状态到jbuf，导致程序
从sigsetjmp（）再次返回（保存的寄存器包含程序计数器和堆栈指针）。
    然而，这一次，sigsetjmp(3C)返回siglongjmp()的第二个参数，是1。注意块
被跳过，在while循环的下一次重复才会执行。
    注意，你可以在多线程编程中用sigsetjmp(3C)和siglongjmp(3C)，但是要小心，
线程永远不会用另一个线程的sigsetjmp()的结果来做siglongjmp()。而且，
sigsetjmp()和siglongjmp()保存和恢复信号掩模，但sigjmp(3C)和longjmp(3C)
不会这样做。如果你使用信号控制器时最好使用sigsetjmp()和siglongjmp()。
    完成语义经常用来处理意外。具体的，Ada语言使用这种模型。
--------------------------------------
注意-sigwait(2)永远不应用来同步信号。
