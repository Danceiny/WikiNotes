概况：2014年微信红包使用数据库硬抗整个流量，2015年使用cache抗流量。


1. 微信的金额什么时候算？ 
答：微信金额是拆的时候实时算出来，不是预先分配的，采用的是纯内存计算，不需要预算空间存储。。 
采取实时计算金额的考虑：预算需要占存储，实时效率很高，预算才效率低。

2. 实时性：为什么明明抢到红包，点开后发现没有？ 
答：2014年的红包一点开就知道金额，分两次操作，先抢到金额，然后再转账。 
2015年的红包的拆和抢是分离的，需要点两次，因此会出现抢到红包了，但点开后告知红包已经被领完的状况。进入到第一个页面不代表抢到，只表示当时红包还有。

3. 分配：红包里的金额怎么算？为什么出现各个红包金额相差很大？ 
答：随机，额度在0.01和剩余平均值*2之间。 
例如：发100块钱，总共10个红包，那么平均值是10块钱一个，那么发出来的红包的额度在0.01元～20元之间波动。 
当前面3个红包总共被领了40块钱时，剩下60块钱，总共7个红包，那么这7个红包的额度在：0.01～（60/7*2）=17.14之间。 

4. 红包的设计 
答：微信从财付通拉取金额数据，生成【个数/红包类型/金额】放到redis集群里，app端将红包ID的请求放入请求队列中（此处请求队列对app端可见？），如果发现超过红包的个数，直接返回。根据红包的逻辑处理成功得到令牌请求，则由财付通进行一致性调用，通过像比特币一样，两边保存交易记录，交易后交给第三方服务审计，如果交易过程中出现不一致就强制回归。

5. 发性处理：红包如何计算被抢完？ 
答：cache会抵抗无效请求，将无效的请求过滤掉，实际进入到后台的量不大。cache记录红包个数，原子操作进行个数递减，到0表示被抢光。财付通按照20万笔每秒入账准备，但实际还不到8万每秒。

6. 一个红包一个队列？ 
答：没有队列，一个红包一条数据，数据上有一个计数器字段。

7. 有没有从数据上证明每个红包的概率是不是均等？ 
答：不是绝对均等，就是一个简单的拍脑袋算法。

8. 每领一个红包就更新数据么？ 
答：每抢到一个红包，就cache更新剩余金额和红包个数。