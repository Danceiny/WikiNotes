

## 1. 最烂
实现一个算法，将长地址转化成短地址，实现长和短一一对应，然后再实现它的逆运算。

>> 这个算法的解是永远找不到的！！！

## 2. 很烂
找一个算法将长地址转成短地址，但是不存在逆运算，这个对应关系存到DB中。

>>不可能实现这样一个绝对不碰撞的hash函数！！！

## 3. 比较栏
用一个hash算法，承认碰撞，碰撞加1加2加3。

>>可能需要做btree式的大于小于或者like查找到【能知道现在应该在后面加1，2或3】，也可能由于输入的长地址集的不确定性，导致生成短地址耗时的不确定性。

## 4. 同样烂
随机生成一个短地址，去查找是否用过，用过就再随机。


# 正确的原理
通过发号策略，给每一个过来的长地址，发一个号即可，小型系统直接用mysql的自增索引，大型应用用分布式的kv系统做发号器（不断自增）。第一个使用这个服务的人得到的短地址是http://xx.xx/0 第二个是 http://xx.xx/1 第11个是 http://xx.xx/a 第依次往后，相当于实现了一个62进制的自增字段即可。（`26*2+10=62`）

1. 62进制如何用db来做？
不需要，db中用10进制即可。

2. 如何保证同一个长地址，每次转出来都是一样的短地址？
发号策略中是不判断长地址是否已经转过的。也就是说用拿着百度首页地址来转，我给一个http://xx.xx/abc 过一段时间你再来转，我还会给你一个 http://xx.xx/xyz。

3. 如何保证发号器的大并发高可用？
可以实现两个发号器，一个发单号，一个发双号，这样就变单点为多点了？依次类推，我们可以实现1000个逻辑发号器，分别发尾号为0到999的号。每发一个号，每个发号器加1000，而不是加1。这些发号器独立工作，互不干扰即可。

5. 跳转用301还是302？
301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。同时对服务器压力也会有一定减少。
但是如果使用了301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择302虽然会增加服务器压力，但是我想是一个更好的选择。

6. 从goo.gl和is.gd的使用经验来看，1. 时间相近的转换结果值并不靠近，2. 很长时间之后重新转换某长网址得到的结果也是相同的。楼主能否介绍一下方案的异同？
不是答主，猜测一下而已。对于“时间相近的转换结果值并不靠近”，可能是你遇到不同的发号机了，所以相距很远。而且他们把发号数字转换成字母的方式也可能不太一样，导致相近的数字转换出完全不像的字母。对于“很长时间之后重新转换某长网址得到的结果也是相同的”，可能是你转换的东西很常用，隔三岔五就有个路人来转换它，所以一直保留在cache。





